There are two different techniques used in embedded systems to handle events or monitor conditions for interfacing with peripherals or managing input/output.
## Polling
it is a technique where the CPU repeatedly checks the status of a specific peripheral or input, like a sensor or button, to determine if it requires processing.

The CPU continuously executes a loop that checks the status of the device or peripheral. (Busy while)
If the device status changes (e.g., a flag is set, or a certain condition is met), the CPU exits the loop or takes action based on this event.
Then the CPU performs any necessary processing (like reading data or responding to the event).
After handling the event, the CPU returns to the polling loop to monitor the device again.

Polling happens at regular intervals called Polling rate:
- Polling rate: is the number of samples per second.
	- ex: keyboard polling rate 125Hz, this means that the keyboard is being scanned 125 times per second.

### Advantages
- Simplicity
- Predictable Timing
### Disadvantages
- **Inefficiency**: Since the CPU is continuously checking the device, it wastes processing power that could be used for other tasks.
- **Increased Power Consumption**: Polling keeps the CPU active even if no event occurs, leading to higher power consumptionâ€”an important consideration in battery-powered devices.
- **Slower Response Time**: Polling might miss events if they occur between checks, making it less responsive compared to interrupt-based methods.
## Interrupt
An interrupt is a **signal** that is generated by hardware or software when a process or an event needs **immediate attention**
### Sources of Interrupts
- Hardware
	- It is an **electrical signal** sent from an **external device** or from an internal peripheral (Timer, ADC, ...)
	- Types:
		- Maskable: These interrupts can be enabled or disables by software.
		- Non-Maskable: These interrupts can not be disabled
- Software
	- it is caused by an 
		- Exceptional condition or
		- A special instruction in the instruction set.


### Interrupt Service Routine (ISR)
ISR is a **function** that takes **void** and returns **void** which will be called to handle the interrupt call, and it does not called by the software.
- It must contain small logic
- It must by optimised by the compiler

``` c
void __vector_1(void) __attribute__ ((signal, used));
```
Adding the `__attribute__` here make the compiler understand that, this function has a special attributes, `signal` means it will be triggered by signal from hardware, `used` which means the function will be used, so it is not optimised (Asks the compiler to do not delete it, because there is no call for it from the application).

### Interrupt Vector Table (IVT)
it is an arrays of pointer to functions which takes void and return void (ISR), so It stores the addresses of ISR, if implemented.
The IVT is stored in the lowest address into the flash memory (IVT section memory).
It is located in the Linker Script or the Startup code.

## Interrupt Life Cycle
1. Fetch and decode instruction
2. Execute Instruction and Check the Global Interrupt Enabled
3. if IEN enabled check the input interrupt if 1 set the interrupt flag, if 0 check the output interrupt.
4. if output interrupt 1 set the interrupt flag, if 0 check the interrupt flag.
5. if interrupt flag is 0 then fetch the next instruction.
6. if interrupt flag is 1 then store the current Program counter value.
7. Set the Program counter with the address of the ISR
8. Execute the ISR
9. Set the Program counter with the return address from ISR
10. Set the interrupt flag to 0

``` mermaid
flowchart TD
	R{R} -->|0| FETCH[Fetch and decode instruction]
	FETCH --> EXEC[Execute instruction]
	FETCH --> IEN{IEN}
	IEN -->|0| R
	IEN -->|1| INTI{Input interrupt}  
	
	INTI -->|0| OUTI{Output interrupt}
	INTI -->|1| SETR(Set R to 1)
	
	OUTI -->|0| R
	OUTI -->|1| SETR 
	
	R -->|1| A[Store PC/return address to memory]
	A --> B[Set PC to the address from IVT]
	B --> C[Execute the interrupt]
	C --> D[Set the PC to the return address]
	D --> E[Set R to 0]
	E --> R
```

Where:
`R` is a flag refers to interrupt event
`IEN` Global Interrupt Enabled.

### Interrupt Latency and Response
- Interrupt latency:
is the delay from the start of the interrupt request to the start of the interrupt execution.
so it is the time of execute the current instruction + the context switching, then starting the ISR.

- Interrupt Response:
Is the time form the start of the interrupt request to the end of the interrupt execution.
so it is the time of executing the current instruction + the context switching + the ISR exection.