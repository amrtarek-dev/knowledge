## Files I/O
Files are opened via file descriptors (fd) which are integers, and kernel maintains a Per-process list of files in file table, and they are indexed by fds.

Every process has at least 3 file descriptors opened:
- stdin (fd 0 or STDIN_FILENO) (terminal input device)
- stdout (fd 1 or STDOUT_FILENO) terminal display
- stderr (fd 2 or STDERR_FILENO) treminal_display

### Opening and Accessing files
- open() (possibly with O_CREAT)
- read()
- write()
- close()

> It is not fopen(), fwrite(), fread().
> `f` prefix related to buffered I/O, not the system calls, the non `f` functions are the system calls functions

#### Buffered I/O - fopen() vs open()
They are the `f` prefix functions from `stdio.h` which are a user space functions that buffer the output from the system call function `read()` for example to reduce the system calls to kernel.

##### open()
open() function maps pathname to file descriptor (return fd) and include open flags argument:
- Access:
	- read only
	- read/write create append
	- synchronous I/O , etc...
- Mode argument:
	- read, write, execute permissions for user/group/other.

##### read()
it takes the file descriptor from open and returns:
- Bytes read
	- value < count means no more bytes are available (You reached the end of the file or read has been interrupted by signal)
- -1 on Error with errno
``` c
int fd=open(filename,
		   O_RDWR | O_CREATE,
		   S_IRWXU | S_IRWXG | S_IRWXO);
```
This will make a blocking open process which you need to wait until there is a data available to continue.
But you can make a non block open by
``` c
int fd=open(filename, 
			O_RDONLY | block ? O_CREAT | O_RDWR : O_NONBLOCK,
			S_IRWXU | S_IRWXG | S_IRWXO)
```
and then you can check for EAGAIN to see if data is available
##### UMASK
it is a universal mask to restrict permissions set on created files. (& ~umask)
``` bash
$ umask
0002
```
this means that it will prevent any user to make the `other` read or write
it is a bit wise mask on.
You can edit the umask
``` bash 
umask 0003
```

##### STRACE
it is a handy too for debugging application interaction with the kernel through syscall.
``` bash
strace ./executable
```
> It does not need the source code, it reads in running time.

##### write()
``` c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```
it writes up to count bytes from the buffer, and it will return number of bytes written.

> Write does not writing directly to disk it is writing into kernel buffer because Disks are slow.

So unclean shutdown can damage the unwritten dat.
To avoid that use:
fsync(), fdatasync(), or O_SYNC at open function to force the syncing process.
or Configure the disk write caching to report write successfully when the data on the disk.